{
  "tecnologia": "ArgoCD",
  "total_preguntas": 20,
  "preguntas": [
    {
      "id": 1,
      "pregunta": "¿Qué es ArgoCD?",
      "nivel": "básico",
      "opciones": [
        "Un servidor web",
        "Un lenguaje de programación",
        "Una herramienta de GitOps para Kubernetes",
        "Una base de datos"
      ],
      "respuestas_correctas": [2],
      "explicacion": "ArgoCD es una herramienta de entrega continua declarativa, GitOps para Kubernetes. Permite gestionar aplicaciones de Kubernetes usando Git como fuente de verdad, implementando los principios de GitOps para automatizar el despliegue y la sincronización de aplicaciones."
    },
    {
      "id": 2,
      "pregunta": "¿Cuál de los siguientes NO es un principio de GitOps que implementa ArgoCD?",
      "nivel": "básico",
      "opciones": [
        "Declarativo",
        "Versionado e inmutable",
        "Pulled automáticamente",
        "Despliegue sin reconciliación continua"
      ],
      "respuestas_correctas": [3],
      "explicacion": "GitOps es declarativo, versionado/inmutable, con extracción automática y <strong>reconciliación continua</strong>. El 'despliegue sin reconciliación continua' no es un principio."
    },
    {
      "id": 3,
      "pregunta": "¿Qué puerto usa ArgoCD por defecto para la UI?",
      "nivel": "básico",
      "opciones": [
        "9090",
        "3000",
        "8000",
        "8080"
      ],
      "respuestas_correctas": [3],
      "explicacion": "ArgoCD utiliza el puerto <strong>8080</strong> por defecto para su interfaz de usuario web. Este puerto puede ser configurado durante la instalación o mediante la configuración del servicio de ArgoCD."
    },
    {
      "id": 4,
      "pregunta": "¿Qué es una Application en ArgoCD?",
      "nivel": "básico",
      "opciones": [
        "Un tipo de contenedor",
        "Una configuración de red",
        "Un recurso que define el estado deseado de una aplicación",
        "Un tipo de base de datos"
      ],
      "respuestas_correctas": [2],
      "explicacion": "Una <strong>Application</strong> en ArgoCD es un Custom Resource Definition (CRD) de Kubernetes que define el estado deseado de una aplicación. Especifica la fuente (repositorio Git), el destino (cluster y namespace), y la herramienta de renderizado (Helm, Kustomize, etc.). Es el objeto principal que ArgoCD utiliza para gestionar el ciclo de vida de las aplicaciones, comparando continuamente el estado actual con el estado deseado definido en Git."
    },
    {
      "id": 5,
      "pregunta": "¿Cuál de los siguientes NO es un componente principal de ArgoCD?",
      "nivel": "básico",
      "opciones": [
        "API Server",
        "Repository Server",
        "Scheduler de Kubernetes",
        "Application Controller"
      ],
      "respuestas_correctas": [2],
      "explicacion": "ArgoCD incluye API Server, Repository Server y Application Controller, entre otros. El <strong>Scheduler de Kubernetes</strong> es un componente del cluster, no de ArgoCD."
    },
    {
      "id": 6,
      "pregunta": "¿Cuál de los siguientes NO es un tipo de repositorio soportado por ArgoCD?",
      "nivel": "intermedio",
      "opciones": [
        "Git repositories",
        "Helm repositories",
        "OCI repositories",
        "Docker registries"
      ],
      "respuestas_correctas": [3],
      "explicacion": "ArgoCD soporta repos <strong>Git</strong>, <strong>Helm</strong> y <strong>OCI</strong> para manifiestos. Los <strong>Docker registries</strong> no son repos de configuración; gestionan imágenes."
    },
    {
      "id": 7,
      "pregunta": "¿Cuál de los siguientes NO es un estado de sincronización en ArgoCD?",
      "nivel": "intermedio",
      "opciones": [
        "Synced",
        "OutOfSync",
        "Unknown",
        "Progressing"
      ],
      "respuestas_correctas": [3],
      "explicacion": "Los estados de sincronización son <strong>Synced</strong>, <strong>OutOfSync</strong> y <strong>Unknown</strong>. <strong>Progressing</strong> es un estado de health, no de sincronización."
    },
    {
      "id": 8,
      "pregunta": "¿Qué es el Application Controller en ArgoCD?",
      "nivel": "intermedio",
      "opciones": [
        "Una interfaz de usuario",
        "Un tipo de base de datos",
        "Una configuración de red",
        "Componente que monitorea aplicaciones y reconcilia el estado"
      ],
      "respuestas_correctas": [3],
      "explicacion": "El <strong>Application Controller</strong> es el componente central de ArgoCD responsable de monitorear continuamente las aplicaciones definidas y reconciliar el estado actual del cluster con el estado deseado definido en Git. Ejecuta un bucle de control que detecta diferencias (drift) y puede aplicar automáticamente los cambios necesarios según las políticas de sincronización configuradas. Es el corazón del proceso GitOps en ArgoCD."
    },
    {
      "id": 9,
      "pregunta": "¿Cuál de las siguientes NO es una estrategia u opción de sincronización en ArgoCD?",
      "nivel": "intermedio",
      "opciones": [
        "Manual sync",
        "Automatic sync",
        "Prune",
        "Blue/Green deployment"
      ],
      "respuestas_correctas": [3],
      "explicacion": "ArgoCD ofrece <strong>manual</strong>, <strong>automático</strong> y <strong>prune</strong>; <strong>Blue/Green</strong> es una estrategia de despliegue, no una opción de sync de ArgoCD."
    },
    {
      "id": 10,
      "pregunta": "¿Qué son los Sync Hooks en ArgoCD?",
      "nivel": "intermedio",
      "opciones": [
        "Tipos de repositorios",
        "Tipos de aplicaciones",
        "Recursos que se ejecutan en momentos específicos del sync",
        "Configuraciones de red"
      ],
      "respuestas_correctas": [2],
      "explicacion": "Los <strong>Sync Hooks</strong> son recursos especiales de Kubernetes (generalmente Jobs o Pods) que se ejecutan en momentos específicos durante el proceso de sincronización. Permiten ejecutar tareas como migraciones de base de datos, validaciones, limpieza de recursos, o cualquier lógica personalizada antes, durante o después de la sincronización. Se definen usando anotaciones especiales en los manifiestos."
    },
    {
      "id": 11,
      "pregunta": "¿Cuál de los siguientes NO es un tipo de Sync Hook?",
      "nivel": "intermedio",
      "opciones": [
        "PreSync",
        "Sync",
        "HealthCheck",
        "PostSync"
      ],
      "respuestas_correctas": [2],
      "explicacion": "Los hooks estándar incluyen <strong>PreSync</strong>, <strong>Sync</strong>, <strong>PostSync</strong>, <strong>SyncFail</strong> y <strong>Skip</strong>. <strong>HealthCheck</strong> no es un tipo de Sync Hook."
    },
    {
      "id": 12,
      "pregunta": "¿Qué es un Project en ArgoCD?",
      "nivel": "avanzado",
      "opciones": [
        "Un tipo de repositorio",
        "Una configuración de red",
        "Un tipo de aplicación",
        "Agrupación lógica de aplicaciones con políticas"
      ],
      "respuestas_correctas": [3],
      "explicacion": "Un <strong>Project</strong> en ArgoCD es una agrupación lógica de aplicaciones que proporciona un mecanismo para implementar políticas de seguridad y governance. Define qué repositorios fuente pueden usarse, qué clusters y namespaces son válidos como destinos, y qué usuarios o grupos tienen acceso. Los Projects son fundamentales para implementar multi-tenancy y control de acceso granular en entornos empresariales."
    },
    {
      "id": 13,
      "pregunta": "¿Cuál de las siguientes NO es una característica de los Projects?",
      "nivel": "avanzado",
      "opciones": [
        "Source repositories permitidos",
        "Clusters de destino permitidos",
        "Definir pipelines de CI/CD",
        "Namespaces permitidos"
      ],
      "respuestas_correctas": [2],
      "explicacion": "Los Projects controlan repos, destinos, namespaces y políticas; <strong>no</strong> definen pipelines de CI/CD."
    },
    {
      "id": 14,
      "pregunta": "¿Qué son las Application Sets?",
      "nivel": "avanzado",
      "opciones": [
        "Tipos de proyectos",
        "Configuraciones de red",
        "Herramienta para generar múltiples aplicaciones ArgoCD",
        "Tipos de repositorios"
      ],
      "respuestas_correctas": [2],
      "explicacion": "Las <strong>Application Sets</strong> son una herramienta avanzada de ArgoCD que permite generar y gestionar múltiples aplicaciones ArgoCD de forma automática y declarativa. Son especialmente útiles para escenarios multi-cluster, multi-tenant, o cuando se necesita desplegar la misma aplicación en múltiples entornos (dev, staging, prod). Utilizan generadores para crear aplicaciones dinámicamente basadas en patrones o fuentes de datos."
    },
    {
      "id": 15,
      "pregunta": "¿Cuál de los siguientes NO es un generador de Application Sets?",
      "nivel": "avanzado",
      "opciones": [
        "List generator",
        "Docker generator",
        "Clusters generator",
        "Git generator"
      ],
      "respuestas_correctas": [1],
      "explicacion": "Application Sets incluye generadores como List, Clusters, Git y Matrix/PR; <strong>Docker generator</strong> no existe como generador."
    },
    {
      "id": 16,
      "pregunta": "¿Qué es el Repository Server?",
      "nivel": "avanzado",
      "opciones": [
        "Una interfaz de usuario",
        "Un tipo de base de datos",
        "Una configuración de aplicación",
        "Servicio que clona repositorios y genera manifiestos"
      ],
      "respuestas_correctas": [3],
      "explicacion": "El <strong>Repository Server</strong> es un componente interno de ArgoCD responsable de clonar repositorios Git y generar los manifiestos Kubernetes finales. Maneja diferentes herramientas de gestión de configuración (Helm, Kustomize, Jsonnet), cachea repositorios para mejorar el rendimiento, y procesa templates y configuraciones para producir los manifiestos YAML que serán aplicados al cluster. Es un servicio stateless que puede escalarse horizontalmente."
    },
    {
      "id": 17,
      "pregunta": "¿Cuál de los siguientes NO es un método de autenticación en ArgoCD?",
      "nivel": "avanzado",
      "opciones": [
        "Local users",
        "SSO (OIDC)",
        "Kerberos",
        "LDAP"
      ],
      "respuestas_correctas": [2],
      "explicacion": "ArgoCD soporta usuarios locales, OIDC/SSO, LDAP, SAML y OAuth; <strong>Kerberos</strong> no es un método soportado nativo."
    },
    {
      "id": 18,
      "pregunta": "¿Qué son las Config Management Tools en ArgoCD?",
      "nivel": "avanzado",
      "opciones": [
        "Tipos de aplicaciones",
        "Configuraciones de red",
        "Herramientas para generar manifiestos Kubernetes",
        "Tipos de proyectos"
      ],
      "respuestas_correctas": [2],
      "explicacion": "Las <strong>Config Management Tools</strong> en ArgoCD son herramientas especializadas para generar y procesar manifiestos Kubernetes a partir de templates, configuraciones o definiciones de alto nivel. Estas herramientas permiten gestionar configuraciones complejas, reutilizar componentes, y mantener diferentes configuraciones para múltiples entornos de forma eficiente y mantenible."
    },
    {
      "id": 19,
      "pregunta": "¿Cuál de las siguientes NO es una Config Management Tool soportada por ArgoCD?",
      "nivel": "avanzado",
      "opciones": [
        "Helm",
        "Kustomize",
        "Docker Compose",
        "Jsonnet"
      ],
      "respuestas_correctas": [2],
      "explicacion": "ArgoCD soporta <strong>Helm</strong>, <strong>Kustomize</strong> y <strong>Jsonnet</strong>, además de YAML y plugins. <strong>Docker Compose</strong> no es una CM tool soportada por ArgoCD."
    },
    {
      "id": 20,
      "pregunta": "¿Cuál de las siguientes NO es una mejor práctica para ArgoCD?",
      "nivel": "avanzado",
      "opciones": [
        "Separar configuración de aplicación del código",
        "Usar Projects para organización",
        "Guardar secretos en texto plano en Git",
        "Implementar RBAC apropiado"
      ],
      "respuestas_correctas": [2],
      "explicacion": "Buenas prácticas: separar configuración, usar Projects y RBAC, monitorizar health, usar Application Sets. <strong>No</strong> se deben guardar secretos en texto plano en Git."
    }
  ]
}