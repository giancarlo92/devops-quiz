{
  "tecnologia": "Prometheus",
  "total_preguntas": 20,
  "preguntas": [
    {
      "id": 1,
      "pregunta": "¿Qué es Prometheus?",
      "nivel": "básico",
      "opciones": [
        "Un sistema de monitoreo y alertas de código abierto",
        "Una base de datos relacional",
        "Un servidor web",
        "Un lenguaje de programación"
      ],
      "respuestas_correctas": [0],
      "explicacion": "Prometheus es un sistema de monitoreo y alertas de código abierto desarrollado originalmente por SoundCloud. Es parte de la Cloud Native Computing Foundation (CNCF) y se ha convertido en el estándar de facto para el monitoreo de aplicaciones cloud-native. Prometheus recolecta métricas de sistemas y aplicaciones, las almacena como series temporales y proporciona un lenguaje de consulta potente (PromQL) para analizarlas. Su arquitectura pull-based y su capacidad de service discovery automático lo hacen ideal para entornos dinámicos como Kubernetes."
    },
    {
      "id": 2,
      "pregunta": "¿Cuál de las siguientes NO es una característica principal de Prometheus?",
      "nivel": "básico",
      "opciones": [
        "Modelo de datos de series temporales",
        "Lenguaje de consulta PromQL",
        "Pull-based metrics collection",
        "Alerting integrado",
        "Transacciones ACID"
      ],
      "respuestas_correctas": [4],
      "explicacion": "**Transacciones ACID** no es una característica de Prometheus; Prometheus usa un TSDB append-only optimizado para series temporales, sin soporte de transacciones ACID ni SQL relacional. Entre sus características clave están el modelo de series temporales, **PromQL**, la recolección **pull**, el **alerting** integrado y el **service discovery** para descubrir targets dinámicamente."
    },
    {
      "id": 3,
      "pregunta": "¿Qué puerto usa Prometheus por defecto?",
      "nivel": "básico",
      "opciones": [
        "9090",
        "8080",
        "3000",
        "8000"
      ],
      "respuestas_correctas": [0],
      "explicacion": "Prometheus utiliza el puerto **9090** por defecto para su interfaz web y API. Este puerto es donde se puede acceder a la interfaz de usuario web de Prometheus, que incluye el explorador de expresiones PromQL, el navegador de targets, y las páginas de configuración y estado. También es el puerto donde otros servicios pueden consultar la API de Prometheus para obtener métricas. Este puerto puede ser configurado usando el flag `--web.listen-address` al iniciar el servidor Prometheus."
    },
    {
      "id": 4,
      "pregunta": "¿Qué son las métricas en Prometheus?",
      "nivel": "básico",
      "opciones": [
        "Medidas numéricas de un sistema en un punto específico del tiempo",
        "Configuraciones del servidor",
        "Tipos de alertas",
        "Archivos de configuración"
      ],
      "respuestas_correctas": [0],
      "explicacion": "Las métricas en Prometheus son **medidas numéricas de un sistema en un punto específico del tiempo**. Representan el estado o comportamiento de una aplicación, servicio o infraestructura. Cada métrica tiene un nombre único y puede incluir labels (etiquetas) que proporcionan dimensiones adicionales para la segmentación y filtrado. Por ejemplo, `http_requests_total{method='GET', status='200'}` es una métrica que cuenta las solicitudes HTTP GET exitosas. Las métricas se almacenan como series temporales, permitiendo el análisis de tendencias y patrones a lo largo del tiempo."
    },
    {
      "id": 5,
      "pregunta": "¿Cuál de los siguientes NO es un tipo de métrica en Prometheus?",
      "nivel": "básico",
      "opciones": [
        "Counter",
        "Gauge",
        "Histogram",
        "Summary",
        "Timer"
      ],
      "respuestas_correctas": [4],
      "explicacion": "**Timer** no es un tipo nativo de métrica en Prometheus. Los tipos soportados son **Counter**, **Gauge**, **Histogram** y **Summary**. Algunos SDKs externos usan 'timers' como envoltorios sobre histogramas o summaries, pero en Prometheus se modelan con esos tipos."
    },
    {
      "id": 6,
      "pregunta": "¿Qué es PromQL?",
      "nivel": "intermedio",
      "opciones": [
        "Lenguaje de consulta de Prometheus",
        "Una base de datos",
        "Un tipo de métrica",
        "Una configuración de alerta"
      ],
      "respuestas_correctas": [0],
      "explicacion": "**PromQL (Prometheus Query Language)** es el lenguaje de consulta funcional de Prometheus que permite seleccionar y agregar datos de series temporales en tiempo real. PromQL está diseñado específicamente para trabajar con datos de series temporales y proporciona operadores para filtrar, agregar y manipular métricas. Incluye funciones para cálculos matemáticos, agregaciones (sum, avg, max, min), operaciones de tiempo (rate, increase), y predicados para filtrado. Por ejemplo: `rate(http_requests_total[5m])` calcula la tasa por segundo de requests HTTP en los últimos 5 minutos."
    },
    {
      "id": 7,
      "pregunta": "¿Cuál de los siguientes NO forma parte del ecosistema de Prometheus?",
      "nivel": "intermedio",
      "opciones": [
        "Prometheus server",
        "Alertmanager",
        "Pushgateway",
        "Node exporter",
        "Kubelet"
      ],
      "respuestas_correctas": [4],
      "explicacion": "**Kubelet** es un componente de Kubernetes, no parte del ecosistema Prometheus. El ecosistema incluye **Prometheus server**, **Alertmanager**, **Pushgateway** y exporters como **Node exporter**. Herramientas como **Grafana** se integran para visualización, pero no forman parte del servidor Prometheus."
    },
    {
      "id": 8,
      "pregunta": "¿Qué es un Counter en Prometheus?",
      "nivel": "intermedio",
      "opciones": [
        "Métrica que solo puede incrementar",
        "Métrica que puede subir y bajar",
        "Métrica que mide distribuciones",
        "Métrica que calcula percentiles"
      ],
      "respuestas_correctas": [0],
      "explicacion": "Un **Counter** es un tipo de métrica en Prometheus que representa un valor acumulativo que **solo puede incrementar** o reiniciarse a cero al reiniciar la aplicación. Los counters son ideales para medir eventos que ocurren continuamente, como el número total de requests HTTP, errores, o bytes transferidos. En PromQL, los counters se usan típicamente con funciones como `rate()` o `increase()` para calcular tasas de cambio. Por ejemplo, `rate(http_requests_total[5m])` calcula la tasa por segundo de requests en los últimos 5 minutos. Los counters nunca deben decrecer durante la operación normal."
    },
    {
      "id": 9,
      "pregunta": "¿Qué es un Gauge en Prometheus?",
      "nivel": "intermedio",
      "opciones": [
        "Métrica que puede subir y bajar",
        "Métrica que solo puede incrementar",
        "Métrica que mide distribuciones",
        "Métrica que calcula percentiles"
      ],
      "respuestas_correctas": [0],
      "explicacion": "Un **Gauge** es un tipo de métrica en Prometheus que representa un valor numérico que **puede subir y bajar arbitrariamente**. Los gauges son perfectos para medir valores instantáneos como uso de memoria, CPU, temperatura, número de conexiones activas, o tamaño de cola. A diferencia de los counters, los gauges representan un estado actual en lugar de un valor acumulativo. En PromQL, los gauges se pueden usar directamente sin funciones de tasa, y son útiles para alertas basadas en umbrales. Por ejemplo, `memory_usage_bytes > 1000000000` para alertar cuando el uso de memoria supera 1GB."
    },
    {
      "id": 10,
      "pregunta": "¿Qué son los labels en Prometheus?",
      "nivel": "intermedio",
      "opciones": [
        "Pares clave-valor que identifican series temporales",
        "Tipos de métricas",
        "Configuraciones de servidor",
        "Tipos de alertas"
      ],
      "respuestas_correctas": [0],
      "explicacion": "Los **labels** en Prometheus son **pares clave-valor que identifican de manera única las series temporales**. Proporcionan dimensiones adicionales a las métricas, permitiendo segmentación y filtrado granular. Por ejemplo, `http_requests_total{method='GET', status='200', endpoint='/api/users'}` tiene tres labels: method, status y endpoint. Los labels permiten consultas específicas como `sum(rate(http_requests_total{status=~'5..'}[5m])) by (endpoint)` para obtener la tasa de errores 5xx por endpoint. Es importante usar labels con cardinalidad controlada, ya que cada combinación única de labels crea una nueva serie temporal."
    },
    {
      "id": 11,
      "pregunta": "¿Qué es el Alertmanager?",
      "nivel": "intermedio",
      "opciones": [
        "Componente que maneja alertas enviadas por Prometheus",
        "Un tipo de métrica",
        "Una configuración de servidor",
        "Un lenguaje de consulta"
      ],
      "respuestas_correctas": [0],
      "explicacion": "**Alertmanager** es un componente separado del ecosistema Prometheus que **maneja alertas enviadas por el servidor Prometheus**. Sus funciones principales incluyen: 1) **Agrupación**: Combina alertas similares en una sola notificación. 2) **Silenciamiento**: Permite suprimir alertas temporalmente. 3) **Inhibición**: Suprime ciertas alertas cuando otras están activas. 4) **Enrutamiento**: Dirige alertas a diferentes receptores basado en labels. 5) **Integración**: Envía notificaciones a múltiples canales (email, Slack, PagerDuty, webhooks). Alertmanager desacopla la detección de alertas (Prometheus) del manejo de notificaciones, proporcionando un sistema robusto y flexible."
    },
    {
      "id": 12,
      "pregunta": "¿Cuál de las siguientes NO es una función de PromQL?",
      "nivel": "avanzado",
      "opciones": [
        "rate()",
        "sum()",
        "increase()",
        "histogram_quantile()",
        "median()"
      ],
      "respuestas_correctas": [4],
      "explicacion": "`median()` no es una función de PromQL. PromQL ofrece funciones como **rate()**, **sum()**, **avg()**, **increase()** y **histogram_quantile()**, entre otras (`max()`, `min()`, `count()`, `topk()`, `bottomk()`, `abs()`, `ceil()`, `floor()`, y funciones de tiempo como `time()` y `day_of_week()`). El cálculo de medianas se logra mediante cuantiles usando **histogram_quantile()** o agregaciones específicas."
    },
    {
      "id": 13,
      "pregunta": "¿Qué es el Service Discovery en Prometheus?",
      "nivel": "avanzado",
      "opciones": [
        "Mecanismo para descubrir automáticamente targets",
        "Un tipo de métrica",
        "Una configuración de alerta",
        "Un componente de visualización"
      ],
      "respuestas_correctas": [0],
      "explicacion": "**Service Discovery** en Prometheus es un **mecanismo para descubrir automáticamente targets** (endpoints) que deben ser monitoreados, sin necesidad de configuración manual estática. Esto es especialmente importante en entornos dinámicos donde los servicios pueden aparecer, desaparecer o cambiar de ubicación frecuentemente. Prometheus actualiza automáticamente su lista de targets basándose en la información del service discovery, aplicando relabeling rules para filtrar y modificar targets según sea necesario. Esto permite un monitoreo escalable y mantenible en arquitecturas cloud-native y microservicios."
    },
    {
      "id": 14,
      "pregunta": "¿Cuál NO es un tipo de Service Discovery soportado por Prometheus?",
      "nivel": "avanzado",
      "opciones": [
        "Kubernetes",
        "Consul",
        "FTP",
        "DNS",
        "File-based"
      ],
      "respuestas_correctas": [2],
      "explicacion": "**FTP** no es un mecanismo de Service Discovery en Prometheus. Entre los soportados se incluyen **Kubernetes**, **Consul**, **EC2**, **DNS** y **file-based**, además de Azure, GCE, Marathon, Zookeeper, Nerve, Serverset, Triton y OpenStack. Cada tipo proporciona metadatos relevantes como labels."
    },
    {
      "id": 15,
      "pregunta": "¿Qué es el Pushgateway?",
      "nivel": "avanzado",
      "opciones": [
        "Servicio para métricas de trabajos de corta duración",
        "Un tipo de métrica",
        "Una configuración de servidor",
        "Un componente de alertas"
      ],
      "respuestas_correctas": [0],
      "explicacion": "**Pushgateway** es un **servicio intermediario para métricas de trabajos de corta duración** que no pueden ser scrapeados directamente por Prometheus. Está diseñado para batch jobs, scripts, y tareas que se ejecutan brevemente y terminan antes de que Prometheus pueda recolectar sus métricas. Los trabajos 'empujan' sus métricas al Pushgateway, y Prometheus luego 'extrae' estas métricas del gateway. Es importante usar Pushgateway solo cuando sea necesario, ya que puede crear puntos únicos de falla y complicar el service discovery. Se recomienda para casos específicos como trabajos cron, scripts de backup, o procesos ETL."
    },
    {
      "id": 16,
      "pregunta": "¿Qué son los recording rules en Prometheus?",
      "nivel": "avanzado",
      "opciones": [
        "Consultas precomputadas para mejorar rendimiento",
        "Tipos de métricas",
        "Configuraciones de alerta",
        "Tipos de exporters"
      ],
      "respuestas_correctas": [0],
      "explicacion": "Los **recording rules** son **consultas PromQL precomputadas que se ejecutan a intervalos regulares para mejorar el rendimiento**. Permiten calcular expresiones complejas o costosas de antemano y almacenar los resultados como nuevas series temporales. Esto es especialmente útil para: 1) Consultas frecuentes en dashboards. 2) Agregaciones complejas que tardan mucho en calcularse. 3) Datos que se consultan en múltiples alertas. 4) Reducir la carga en consultas en tiempo real. Los recording rules se definen en archivos de configuración y se evalúan según el intervalo especificado, creando métricas derivadas que pueden consultarse como cualquier otra métrica."
    },
    {
      "id": 17,
      "pregunta": "¿Cuál de las siguientes NO es una buena práctica para nombrar métricas?",
      "nivel": "avanzado",
      "opciones": [
        "Usar snake_case",
        "Usar camelCase y espacios",
        "Ser descriptivo pero conciso",
        "Evitar espacios y caracteres especiales",
        "Usar prefijos consistentes"
      ],
      "respuestas_correctas": [1],
      "explicacion": "**Usar camelCase y espacios** no es una buena práctica en Prometheus. Se recomienda **snake_case**, incluir unidades (`_bytes`, `_seconds`, `_total`), ser descriptivo pero conciso, evitar caracteres especiales y usar prefijos consistentes. También se sugiere usar sufijos estándar como `_total` para counters y `_bucket` para histogramas."
    },
    {
      "id": 18,
      "pregunta": "¿Qué es la retención de datos en Prometheus?",
      "nivel": "avanzado",
      "opciones": [
        "Tiempo que se mantienen los datos antes de ser eliminados",
        "Un tipo de métrica",
        "Una configuración de alerta",
        "Un tipo de exporter"
      ],
      "respuestas_correctas": [0],
      "explicacion": "La **retención de datos** en Prometheus es el **tiempo que se mantienen los datos almacenados antes de ser eliminados automáticamente**. Por defecto, Prometheus retiene datos por 15 días, pero esto es configurable usando el flag `--storage.tsdb.retention.time`. También se puede configurar retención basada en tamaño usando `--storage.tsdb.retention.size`. La retención es importante para: 1) Gestionar el espacio en disco. 2) Controlar costos de almacenamiento. 3) Cumplir con políticas de datos. Para retención a largo plazo, se recomienda usar remote storage o herramientas como Thanos, Cortex, o VictoriaMetrics que proporcionan almacenamiento escalable y duradero."
    },
    {
      "id": 19,
      "pregunta": "¿Cuál de las siguientes NO es una estrategia de escalabilidad para Prometheus?",
      "nivel": "avanzado",
      "opciones": [
        "Federation",
        "Agregar más dashboards en Grafana",
        "Remote storage",
        "Horizontal scaling",
        "Recording rules"
      ],
      "respuestas_correctas": [1],
      "explicacion": "**Agregar más dashboards en Grafana** no escala Prometheus. Las estrategias válidas incluyen **federation**, **sharding**, **remote storage**, **escalado horizontal** y **recording rules**. También se puede optimizar los intervalos de scrape, usar relabeling para reducir cardinalidad y emplear proxies o load balancers."
    },
    {
      "id": 20,
      "pregunta": "¿Qué son los exporters en Prometheus?",
      "nivel": "avanzado",
      "opciones": [
        "Programas que exponen métricas en formato Prometheus",
        "Tipos de métricas",
        "Configuraciones de servidor",
        "Tipos de alertas"
      ],
      "respuestas_correctas": [0],
      "explicacion": "Los **exporters** son **programas que exponen métricas en formato Prometheus** para sistemas que no tienen instrumentación nativa de Prometheus. Actúan como traductores, convirtiendo métricas de sistemas existentes al formato que Prometheus puede entender. Tipos de exporters incluyen: 1) **Oficiales**: Node exporter (métricas de sistema), Blackbox exporter (probing), MySQL exporter, etc. 2) **De terceros**: Para bases de datos, servicios cloud, aplicaciones específicas. 3) **Personalizados**: Desarrollados para aplicaciones específicas. Los exporters exponen métricas en el endpoint `/metrics` usando el formato de texto de Prometheus, permitiendo que Prometheus los scrape como cualquier otro target."
    }
  ]
}