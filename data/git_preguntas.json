{
  "tecnologia": "Git",
  "descripcion": "Sistema de control de versiones distribuido",
  "total_preguntas": 20,
  "preguntas": [
    {
      "id": 1,
      "nivel": "básico",
      "pregunta": "¿Qué es Git?",
      "opciones": [
        "Un editor de texto",
        "Un sistema de control de versiones distribuido",
        "Un lenguaje de programación",
        "Una base de datos"
      ],
      "respuestas_correctas": [1],
      "explicacion": "Git es un <strong>sistema de control de versiones distribuido</strong> creado por Linus Torvalds. Permite rastrear cambios en archivos, colaborar con otros desarrolladores, mantener un historial completo de modificaciones y trabajar de forma distribuida sin necesidad de un servidor central."
    },
    {
      "id": 2,
      "nivel": "básico",
      "pregunta": "¿Qué comando agrega todos los archivos modificados al área de staging?",
      "opciones": [
        "git add .",
        "git commit -m 'mensaje'",
        "git add archivo.txt",
        "git status"
      ],
      "respuestas_correctas": [0],
      "explicacion": "El comando <strong>git add .</strong> agrega <strong>todos los archivos modificados</strong> al área de staging. 'git add archivo.txt' agrega un archivo específico; 'git commit' confirma cambios y 'git status' muestra el estado."
    },
    {
      "id": 3,
      "nivel": "básico",
      "pregunta": "¿Cómo se inicializa un repositorio Git?",
      "opciones": [
        "git start",
        "git init",
        "git create",
        "git new"
      ],
      "respuestas_correctas": [1],
      "explicacion": "El comando <strong>git init</strong> inicializa un nuevo repositorio Git en el directorio actual. Crea la carpeta oculta .git que contiene toda la metadata necesaria para el control de versiones, incluyendo el historial de commits, configuración y referencias."
    },
    {
      "id": 4,
      "nivel": "básico",
      "pregunta": "¿Qué información NO muestra 'git status'?",
      "opciones": [
        "Archivos modificados",
        "Archivos en staging area",
        "Historial detallado de commits",
        "Archivos no rastreados"
      ],
      "respuestas_correctas": [2],
      "explicacion": "'git status' muestra archivos <strong>modificados</strong>, en <strong>staging</strong> y <strong>no rastreados</strong>, pero <strong>no</strong> muestra el historial detallado de commits. Para ver el historial se usa 'git log'."
    },
    {
      "id": 5,
      "nivel": "básico",
      "pregunta": "¿Cuál es la sintaxis correcta para clonar un repositorio?",
      "opciones": [
        "git clone <URL>",
        "git download <URL>",
        "git copy <URL>",
        "git pull <URL>"
      ],
      "respuestas_correctas": [0],
      "explicacion": "La sintaxis correcta es <strong>git clone &lt;URL&gt;</strong>. Este comando descarga una copia completa del repositorio remoto, incluyendo todo el historial de commits, ramas y tags. Crea un directorio local con el nombre del repositorio y configura automáticamente el remote 'origin'."
    },
    {
      "id": 6,
      "nivel": "intermedio",
      "pregunta": "¿Qué comando crea una nueva rama sin cambiar a ella?",
      "opciones": [
        "git branch nueva-rama",
        "git checkout -b nueva-rama",
        "git switch -c nueva-rama",
        "git create nueva-rama"
      ],
      "respuestas_correctas": [0],
      "explicacion": "<strong>git branch nueva-rama</strong> <strong>crea</strong> una rama <strong>sin cambiar</strong> a ella. <strong>git checkout -b</strong> y <strong>git switch -c</strong> crean y cambian a la nueva rama. 'git create' no existe."
    },
    {
      "id": 7,
      "nivel": "intermedio",
      "pregunta": "¿Cuál de las siguientes afirmaciones es INCORRECTA sobre 'git merge' y 'git rebase'?",
      "opciones": [
        "Merge crea un commit de fusión",
        "Rebase reescribe el historial",
        "Merge preserva el historial original",
        "Rebase es más seguro que merge"
      ],
      "respuestas_correctas": [3],
      "explicacion": "<strong>Rebase no es más seguro que merge</strong>. Merge crea un <strong>commit de fusión</strong> y preserva el <strong>historial original</strong>; rebase <strong>reescribe el historial</strong> aplicando commits uno por uno."
    },
    {
      "id": 8,
      "nivel": "intermedio",
      "pregunta": "¿Cuál de las siguientes NO describe 'git stash'?",
      "opciones": [
        "Guardar cambios temporalmente",
        "Eliminar archivos",
        "Cambiar de rama sin commit",
        "Aplicar cambios guardados luego"
      ],
      "respuestas_correctas": [1],
      "explicacion": "<strong>git stash</strong> <strong>guarda cambios temporalmente</strong>, permite <strong>cambiar de rama sin commit</strong> y luego <strong>aplicarlos</strong>. <strong>No elimina archivos</strong> (esa opción es incorrecta)."
    },
    {
      "id": 9,
      "nivel": "intermedio",
      "pregunta": "¿Qué comando deshace el último commit manteniendo los cambios en el working directory?",
      "opciones": [
        "git reset --soft HEAD~1",
        "git reset --hard HEAD~1",
        "git revert HEAD",
        "git reset --mixed HEAD~1"
      ],
      "respuestas_correctas": [3],
      "explicacion": "<strong>git reset --mixed HEAD~1</strong> deshace el último commit y <strong>mantiene los cambios en el working directory</strong> (quitándolos del staging). '--soft' mantiene cambios en staging; '--hard' elimina cambios; 'revert' crea un nuevo commit inverso."
    },
    {
      "id": 10,
      "nivel": "intermedio",
      "pregunta": "Tras resolver manualmente los conflictos, ¿qué se debe hacer para completar el merge?",
      "opciones": [
        "Hacer commit después de resolver",
        "Usar git merge --abort",
        "Cambiar a otra rama",
        "Eliminar el repositorio"
      ],
      "respuestas_correctas": [0],
      "explicacion": "Tras editar y resolver los conflictos, se debe <strong>hacer commit</strong> para completar el merge. 'merge --abort' cancela el merge; cambiar de rama o borrar el repo no resuelve el conflicto."
    },
    {
      "id": 11,
      "nivel": "intermedio",
      "pregunta": "¿Qué comando cambia la URL de un remote existente?",
      "opciones": [
        "git remote add origin <URL>",
        "git remote set-url origin <URL>",
        "git clone <URL>",
        "git push origin main"
      ],
      "respuestas_correctas": [1],
      "explicacion": "<strong>git remote set-url origin &lt;URL&gt;</strong> <strong>cambia la URL</strong> de un remote existente. 'remote add' agrega un nuevo remote; 'clone' configura 'origin' automáticamente; 'push' envía cambios."
    },
    {
      "id": 12,
      "nivel": "avanzado",
      "pregunta": "¿Para qué se utiliza 'git cherry-pick'?",
      "opciones": [
        "Aplicar commits específicos de otra rama",
        "Seleccionar archivos para commit",
        "Elegir la mejor rama",
        "Aplicar solo cambios específicos"
      ],
      "respuestas_correctas": [0],
      "explicacion": "Git cherry-pick se utiliza para <strong>aplicar commits específicos de otra rama</strong> al branch actual. Toma un commit específico (identificado por su hash) y lo aplica como un nuevo commit en la rama actual, manteniendo los mismos cambios pero con un nuevo hash. Es útil para aplicar fixes específicos sin hacer merge completo."
    },
    {
      "id": 13,
      "nivel": "avanzado",
      "pregunta": "¿Cuál describe mejor el propósito de 'git bisect'?",
      "opciones": [
        "Encontrar el commit que introdujo un bug mediante búsqueda binaria",
        "Dividir el repositorio en dos",
        "Comparar dos ramas",
        "Mostrar diferencias entre commits"
      ],
      "respuestas_correctas": [0],
      "explicacion": "<strong>git bisect</strong> sirve para <strong>encontrar el commit que introdujo un bug</strong> mediante <strong>búsqueda binaria</strong> en el historial marcando commits como 'good' o 'bad'."
    },
    {
      "id": 14,
      "nivel": "avanzado",
      "pregunta": "¿Cuál de los siguientes NO es un hook de Git?",
      "opciones": [
        "pre-commit",
        "post-receive",
        "pre-push",
        "pre-deploy"
      ],
      "respuestas_correctas": [3],
      "explicacion": "<strong>pre-deploy</strong> no existe como hook nativo en Git. Hooks válidos incluyen <strong>pre-commit</strong>, <strong>post-receive</strong>, <strong>pre-push</strong>, <strong>post-merge</strong>, entre otros."
    },
    {
      "id": 15,
      "nivel": "avanzado",
      "pregunta": "¿Cuál de las siguientes NO es un efecto de 'git reset --hard HEAD~1'?",
      "opciones": [
        "Eliminar el último commit",
        "Resetea el working directory",
        "Resetea el staging area",
        "Mantiene los cambios en working directory"
      ],
      "respuestas_correctas": [3],
      "explicacion": "'<strong>reset --hard</strong>' <strong>elimina el último commit</strong>, <strong>resetea el working directory</strong> y <strong>resetea el staging area</strong>. <strong>No mantiene</strong> los cambios en el working directory (eso sería --soft o --mixed)."
    },
    {
      "id": 16,
      "nivel": "avanzado",
      "pregunta": "¿Qué registra 'git reflog'?",
      "opciones": [
        "Movimientos de HEAD",
        "Comandos de shell",
        "Referencias remotas",
        "Cambios de permisos"
      ],
      "respuestas_correctas": [0],
      "explicacion": "<strong>git reflog</strong> <strong>registra movimientos de HEAD</strong> (cambios de rama, commits, resets, etc.). Con esa información es posible recuperar referencias perdidas tras operaciones destructivas."
    },
    {
      "id": 17,
      "nivel": "avanzado",
      "pregunta": "¿Cuál de las siguientes NO es una opción del rebase interactivo?",
      "opciones": [
        "pick (usar commit)",
        "squash (combinar commits)",
        "edit (modificar commit)",
        "stage (preparar cambios)"
      ],
      "respuestas_correctas": [3],
      "explicacion": "Las opciones del rebase interactivo incluyen <strong>pick</strong>, <strong>squash</strong>, <strong>edit</strong>, <strong>drop</strong>, <strong>reword</strong> y <strong>fixup</strong>. <strong>stage</strong> no es una opción del rebase; preparar cambios se hace con 'git add'."
    },
    {
      "id": 18,
      "nivel": "avanzado",
      "pregunta": "¿Cuál de las siguientes NO describe 'git worktree'?",
      "opciones": [
        "Múltiples working directories",
        "Trabajar en diferentes ramas simultáneamente",
        "Crear árboles de trabajo separados",
        "Sincronizar repositorios diferentes"
      ],
      "respuestas_correctas": [3],
      "explicacion": "<strong>git worktree</strong> permite <strong>múltiples working directories</strong> del mismo repo, <strong>trabajar en ramas simultáneamente</strong> y <strong>crear árboles de trabajo separados</strong>. <strong>No sincroniza repositorios diferentes</strong>."
    },
    {
      "id": 19,
      "nivel": "avanzado",
      "pregunta": "¿Cuál de los siguientes NO es un comando válido de 'git subtree'?",
      "opciones": [
        "git subtree add",
        "git subtree pull",
        "git subtree push",
        "git subtree merge"
      ],
      "respuestas_correctas": [3],
      "explicacion": "Los comandos válidos son: <strong>add</strong>, <strong>pull</strong> y <strong>push</strong>. <strong>git subtree merge</strong> <strong>no existe</strong>; el merge se gestiona implícitamente en pull."
    },
    {
      "id": 20,
      "nivel": "avanzado",
      "pregunta": "¿Qué estrategia se utiliza para fusionar múltiples ramas simultáneamente?",
      "opciones": [
        "recursive",
        "octopus",
        "ours",
        "subtree"
      ],
      "respuestas_correctas": [1],
      "explicacion": "La estrategia <strong>octopus</strong> se utiliza para <strong>fusionar múltiples ramas</strong> en un solo merge. 'recursive' es la estrategia por defecto para dos ramas; 'ours' descarta cambios del otro lado; 'subtree' se usa en repos con estructura de subárbol."
    }
  ]
}